<<<<<<< HEAD
import type { BSONSerializeOptions, Document } from '../bson';
import { type MongoDBResponseConstructor } from '../cmap/wire_protocol/responses';
import { type Db } from '../db';
import { type TODO_NODE_3286 } from '../mongo_types';
import type { ReadPreferenceLike } from '../read_preference';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { type TimeoutContext } from '../timeout';
import { MongoDBNamespace } from '../utils';
import { AbstractOperation } from './operation';
=======
import { type Abortable } from '..';
import type { BSONSerializeOptions, Document } from '../bson';
import { type Connection } from '../cmap/connection';
import { CursorResponse, MongoDBResponse } from '../cmap/wire_protocol/responses';
import { AbstractOperation } from '../operations/operation';
import type { ReadPreferenceLike } from '../read_preference';
import type { ServerCommandOptions } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { type TimeoutContext } from '../timeout';
import { type MongoDBNamespace } from '../utils';
>>>>>>> 7bd003e8c643a59b02ef5f2a4588bf20b0d10a0d

/** @public */
export type RunCommandOptions = {
  /** Specify ClientSession for this command */
  session?: ClientSession;
  /** The read preference */
  readPreference?: ReadPreferenceLike;
  /**
   * @experimental
   * Specifies the time an operation will run until it throws a timeout error
   */
  timeoutMS?: number;
  /** @internal */
  omitMaxTimeMS?: boolean;
<<<<<<< HEAD
} & BSONSerializeOptions;

/** @internal */
export class RunCommandOperation<T = Document> extends AbstractOperation<T> {
  command: Document;
  override options: RunCommandOptions & { responseType?: MongoDBResponseConstructor };

  constructor(
    parent: Db,
    command: Document,
    options: RunCommandOptions & { responseType?: MongoDBResponseConstructor }
  ) {
    super(options);
    this.command = command;
    this.options = options;
    this.ns = parent.s.namespace.withCollection('$cmd');
=======

  /**
   * @internal Hints to `executeOperation` that this operation should not unpin on an ended transaction
   * This is only used by the driver for transaction commands
   */
  bypassPinningCheck?: boolean;
} & BSONSerializeOptions &
  Abortable;

/** @internal */
export class RunCommandOperation<T = Document> extends AbstractOperation<T> {
  override SERVER_COMMAND_RESPONSE_TYPE = MongoDBResponse;
  command: Document;
  override options: RunCommandOptions;

  constructor(namespace: MongoDBNamespace, command: Document, options: RunCommandOptions) {
    super(options);
    this.command = command;
    this.options = options;
    this.ns = namespace.withCollection('$cmd');
>>>>>>> 7bd003e8c643a59b02ef5f2a4588bf20b0d10a0d
  }

  override get commandName() {
    return 'runCommand' as const;
  }

<<<<<<< HEAD
  override async execute(
    server: Server,
    session: ClientSession | undefined,
    timeoutContext: TimeoutContext
  ): Promise<T> {
    this.server = server;
    const res: TODO_NODE_3286 = await server.command(
      this.ns,
      this.command,
      {
        ...this.options,
        readPreference: this.readPreference,
        session,
        timeoutContext
      },
      this.options.responseType
    );

    return res;
  }
}

export class RunAdminCommandOperation<T = Document> extends AbstractOperation<T> {
  command: Document;
  override options: RunCommandOptions & {
    noResponse?: boolean;
    bypassPinningCheck?: boolean;
  };

  constructor(
    command: Document,
    options: RunCommandOptions & {
      noResponse?: boolean;
      bypassPinningCheck?: boolean;
    }
  ) {
    super(options);
    this.command = command;
    this.options = options;
    this.ns = new MongoDBNamespace('admin', '$cmd');
  }

  override get commandName() {
    return 'runCommand' as const;
  }

  override async execute(
    server: Server,
    session: ClientSession | undefined,
    timeoutContext: TimeoutContext
  ): Promise<T> {
    this.server = server;
    const res: TODO_NODE_3286 = await server.command(this.ns, this.command, {
      ...this.options,
      readPreference: this.readPreference,
      session,
      timeoutContext
    });
    return res;
=======
  override buildCommand(_connection: Connection, _session?: ClientSession): Document {
    return this.command;
  }

  override buildOptions(timeoutContext: TimeoutContext): ServerCommandOptions {
    return {
      ...this.options,
      session: this.session,
      timeoutContext,
      signal: this.options.signal,
      readPreference: this.options.readPreference
    };
  }
}

/**
 * @internal
 *
 * A specialized subclass of RunCommandOperation for cursor-creating commands.
 */
export class RunCursorCommandOperation extends RunCommandOperation {
  override SERVER_COMMAND_RESPONSE_TYPE = CursorResponse;

  override handleOk(
    response: InstanceType<typeof this.SERVER_COMMAND_RESPONSE_TYPE>
  ): CursorResponse {
    return response;
>>>>>>> 7bd003e8c643a59b02ef5f2a4588bf20b0d10a0d
  }
}
